
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>On the road</title>
  <meta name="author" content="Yang Juven">

  
  <meta name="description" content="我很不喜欢wordpress的在线编辑器，很蛋疼，很多时候调试起格式来很麻烦。
我是个“所想即所得”的忠实者，很多时候觉得，用“what you think is what you
get”的思想
编辑起文档特省事儿。我平时用的最多编辑器就是vim了。因此写博客的时候，很喜欢
用Blogit. &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://yangjuven.github.com/blog/page/2">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="On the road" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-31079582-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">On the road</a></h1>
  
    <h2>求索路上⋯⋯</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:yangjuven.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/07/11/blogit-vim-code-highlight/">Blogit.vim插入代码实现语法高亮</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-07-11T00:00:00+08:00" pubdate data-updated="true">Jul 11<span>th</span>, 2011</time>
        
         | <a href="/blog/2011/07/11/blogit-vim-code-highlight/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>我很不喜欢wordpress的在线编辑器，很蛋疼，很多时候调试起格式来很麻烦。
我是个“所想即所得”的忠实者，很多时候觉得，用“what you think is what you
get”的思想
编辑起文档特省事儿。我平时用的最多编辑器就是vim了。因此写博客的时候，很喜欢
用Blogit.vim这个插件。满足了俺的两大爱好</p>

<ul>
  <li>用vim编辑blog</li>
  <li>所见即所得，编辑起来麻利</li>
</ul>

<p>但是用Blogit.vim编辑起来有个不爽的事儿，插入代码的时候怎么实现语法高亮呢？
最终还是被俺琢磨出一套方案:</p>

<ul>
  <li>Blogit.vim中的所想即所得使用markdown格式</li>
  <li>语法高亮的插件使用我修改过的Google Syntax Highlighter</li>
</ul>

<p>在.vimrc中配置Blogit.vim的format时，用markdown，关于markdown的使用以及如何插入代码，请看<a href="http://johnmacfarlane.net/pandoc/README.html">Pandoc
User’s Guide</a>， .virmc关于Blogit.vim的修改配置如下：</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
</pre></td>
  <td class="code"><pre>let blogit_unformat='pandoc --from=html --to=markdown --reference-links'
let blogit_format='pandoc --from=markdown --to=html --no-wrap'
</pre></td>
</tr></table>
</div>

<p>之后就是修改插件Google Syntax
Highlighter了，因此这个高亮插件与markdown还是有点冲突，在pre标签之间
多了一对code标签，这样就造成在ie浏览器上并不能正确的高亮显示。修改起来也很简单，发现pre标签下存在code标签，
去掉就ok了。仅仅修改shCore.js文件即可。代码如下，添加了一个判断条件。</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
</pre></td>
  <td class="code"><pre><span class="keyword">if</span> (_7d.firstChild.nodeType == <span class="integer">1</span>) {
    _76.Highlight(_7d[_78].replace(<span class="regexp"><span class="delimiter">/</span><span class="content">^</span><span class="char">\s</span><span class="content">*&lt;code&gt;</span><span class="delimiter">/</span><span class="modifier">i</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>).replace(<span class="regexp"><span class="delimiter">/</span><span class="content">&lt;</span><span class="content">\/</span><span class="content">code&gt;</span><span class="char">\s</span><span class="content">*$</span><span class="delimiter">/</span><span class="modifier">i</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>));
}<span class="keyword">else</span>{
    _76.Highlight(_7d[_78]);
}
</pre></td>
</tr></table>
</div>

<p>我也已经将上述修改打包好，想省事儿的话，直接下载即可<a href="http://dl.dropbox.com/u/5738422/google-syntax-highlighter.zip">Google Syntax
Highlighter</a>。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/07/10/transfer-encoding/">Transfer-Encoding的作用</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-07-10T00:00:00+08:00" pubdate data-updated="true">Jul 10<span>th</span>, 2011</time>
        
         | <a href="/blog/2011/07/10/transfer-encoding/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>通过HTTP传送数据时，有些时候并不能事先确定body的长度，因此无法得到<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13">Content-Length</a>的值，
就不能在header中指定Content-Length了，造成的最直接的影响就是：接收方无法通过Content-Length得到报文体的长度，
那怎么判断发送方发送完毕了呢？HTTP
1.1协议在header中引入了<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.41">Transfer-Encoding</a>，当其值为chunked时,
表明采用chunked编码方式来进行报文体的传输。chunked编码的基本方法是将大块数据分解成多块小数据，每块都可以自指定长度，
其格式如下:</p>

<blockquote>
  <p>If a Transfer-Encoding field with a value of chunked is specified in
an HTTP message (either a request sent by a client or the response
from the server), the body of the message consists of an unspecified
number of chunks, a terminating last-chunk, an optional trailer of
entity header fields, and a final CRLF sequence.</p>
</blockquote>

<blockquote>
  <p>Each chunk starts with the number of octets of the data it embeds
expressed in hexadecimal followed by optional parameters (chunk
extension) and a terminating CRLF (carriage return and line feed)
sequence, followed by the chunk data. The chunk is terminated by CRLF.
If chunk extensions are provided, the chunk size is terminated by a
semicolon followed with the extension name and an optional equal sign
and value.</p>
</blockquote>

<blockquote>
  <p>The last chunk is a zero-length chunk, with the chunk size coded as 0,
but without any chunk data section. The final chunk may be followed by
an optional trailer of additional entity header fields that are
normally delivered in the HTTP header to allow the delivery of data
that can only be computed after all chunk data has been generated. The
sender may indicate in a Trailer header field which additional fields
it will send in the trailer after the chunks.</p>
</blockquote>

<p>但凡web server支持 HTTP
1.1，就应该支持Transfer-Encoding的传送方式。apache当然也支持这种传送方式。
简简单单写个程序验证下。</p>

<p>服务器端，一个cgi(mirror.cgi)，将获取的标准输入直接输出到标准输出即可。也就是说将从客户端获得的报文体又作为报文体返回给客户端。
这样来验证客户端通过Transfer-Encoding传送，是否达到预想的目的。</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
</pre></td>
  <td class="code"><pre><span class="comment">#!/usr/bin/env python</span>

<span class="keyword">import</span> <span class="include">sys</span>

BUFFER_SIZE = <span class="integer">1024</span>

sys.stdout.write(<span class="string"><span class="delimiter">&quot;</span><span class="content">Content-type: text/html</span><span class="char">\n</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>)
<span class="keyword">while</span> <span class="predefined-constant">True</span>:
    buffer = sys.stdin.read(BUFFER_SIZE)
    sys.stdout.write(<span class="predefined">buffer</span>)

    <span class="keyword">if</span> <span class="predefined">len</span>(<span class="predefined">buffer</span>) != BUFFER_SIZE:
        <span class="keyword">break</span>
</pre></td>
</tr></table>
</div>

<p>客户端，按照Transfer-Encoding为chunked的format，来传递数据。比如我们想传递一个文件名为file的文件内容
作为报文体的内容传送给服务端。由于file的内容比较大，一下子传递，内存估计吃不消，就可以采用分批传送。</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
<a href="#n14" name="n14">14</a>
<a href="#n15" name="n15">15</a>
<a href="#n16" name="n16">16</a>
<a href="#n17" name="n17">17</a>
</pre></td>
  <td class="code"><pre><span class="comment">#!/usr/bin/env python</span>

<span class="keyword">import</span> <span class="include">httplib</span>

conn = httplib.HTTPConnection(<span class="string"><span class="delimiter">&quot;</span><span class="content">127.0.0.1</span><span class="delimiter">&quot;</span></span>)
conn.putrequest(<span class="string"><span class="delimiter">&quot;</span><span class="content">PUT</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">/cgi-bin/mirror.cgi</span><span class="delimiter">&quot;</span></span>)
conn.putheader(<span class="string"><span class="delimiter">&quot;</span><span class="content">Transfer-Encoding</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">chunked</span><span class="delimiter">&quot;</span></span>)
conn.endheaders()

<span class="keyword">with</span> <span class="predefined">open</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">file</span><span class="delimiter">&quot;</span></span>) <span class="keyword">as</span> fp:
    <span class="keyword">for</span> line <span class="keyword">in</span> fp.readlines():
        conn.send(<span class="string"><span class="delimiter">&quot;</span><span class="content">%x</span><span class="delimiter">&quot;</span></span> % <span class="predefined">len</span>(line) + <span class="string"><span class="delimiter">&quot;</span><span class="char">\r</span><span class="char">\n</span><span class="delimiter">&quot;</span></span> + line + <span class="string"><span class="delimiter">&quot;</span><span class="char">\r</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>)

conn.send(<span class="string"><span class="delimiter">&quot;</span><span class="content">0</span><span class="char">\r</span><span class="char">\n</span><span class="char">\r</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>)

response = conn.getresponse()
<span class="keyword">print</span> response.read()
</pre></td>
</tr></table>
</div>

<p>References &amp; Resources:</p>

<ul>
  <li><a href="http://en.wikipedia.org/wiki/Chunked_transfer_encoding">Chunked transfer encoding</a></li>
  <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.41">RFC2616 Transfer-Encoding</a></li>
  <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6">RFC2616 Transfer-Codings</a></li>
  <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13">RFC2616 Content-Length</a></li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/07/01/python-yield/">Python Yield分享</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-07-01T00:00:00+08:00" pubdate data-updated="true">Jul 1<span>st</span>, 2011</time>
        
         | <a href="/blog/2011/07/01/python-yield/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content">前不久在组内分享了《python yield》，反响很不错，现在放出幻灯片
<div style="width:425px" id="__ss_8477786"> <strong style="display:block;margin:12px 0 4px"><a href="http://www.slideshare.net/yangjuven/python-yield" title="Python Yield" target="_blank">Python Yield</a></strong> <iframe src="http://www.slideshare.net/slideshow/embed_code/8477786" width="425" height="355" frameborder="0" marginwidth="0" marginheight="0" scrolling="no"></iframe> <div style="padding:5px 0 12px"> View more <a href="http://www.slideshare.net/" target="_blank">presentations</a> from <a href="http://www.slideshare.net/yangjuven" target="_blank">yangjuven</a> </div> </div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/06/25/limit-post-request-refer-to-deny-csrf/">限制POST请求的referer来阻止CSRF攻击</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-06-25T00:00:00+08:00" pubdate data-updated="true">Jun 25<span>th</span>, 2011</time>
        
         | <a href="/blog/2011/06/25/limit-post-request-refer-to-deny-csrf/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>什么是CSRF？不懂的同学请点击<a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">这里</a>，不想在这里累赘。</p>

<p>怎么阻止呢？用户虽然能够伪造请求甚至是post请求，但是却不能够伪造referer，因此对于系统的所有post请求限制referer，如果referer为空或者不是系统域，便deny这个请求。通过apache配置便可以实现，大概配置指令如下：</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
</pre></td>
  <td class="code"><pre>SetEnvIfNoCase Request_Method post csrf
SetEnvIfNoCase Referer ^http://youhostname\.com !csrf

&lt;LocationMatch /&gt;
    Order Deny, Allow
    Deny from env=csrf
&lt;/LocationMatch&gt;
</pre></td>
</tr></table>
</div>

<p>优点：</p>

<ul>
  <li>开发者负担小，基本上不用关心任何CSRF，对于开发者来说是透明的。</li>
</ul>

<p>缺点（缺点后面带有我的“辩解”）：</p>

<ul>
  <li>
    <p>用户有可能修改浏览器配置禁止发送referer。我觉得这个跟cookie的情况一样，有很多用户禁止掉了cookie，但是我们还是根据cookie来判断用户的登录状态。</p>
  </li>
  <li>
    <p>某些情况下，有可能http请求中的referer为空。比如谢杨所说的从ftp和https过来的页面，不过这些情况下基本上是属于cross
site，并且如果这些请求是post请求，可以deny这个请求。</p>
  </li>
  <li>
    <p>RF攻击(注意：这里没有CS)。一般情况下，只有post请求才会给用户带来损失，才会给攻击者带来利益。姑且不说现在GS系统没有诸如论坛之类的，即使有，如果在我们的站点发起RF攻击，A用户在查看B用户输入的内容，该内容可以伪造post请求骗取A点击，只能说明我们对用户输入检查没有做好。</p>
  </li>
</ul>

<p>所以，我觉得这种方法简单易行。接下来，我所在的系统就要采用这种方法来阻止CSRF攻击了。</p>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/05/25/mysql-row-lock-and-table-lock/">Mysql Row Lock and Table Lock</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-05-25T00:00:00+08:00" pubdate data-updated="true">May 25<span>th</span>, 2011</time>
        
         | <a href="/blog/2011/05/25/mysql-row-lock-and-table-lock/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在《深入浅出mysql》一书中，“20.3.4 InnoDB行锁实现方式”一节中，有这样一句话</p><blockquote><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，这个特点意味着： 只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。</p></blockquote><p>尽信书不如无书，这句话我一直深信不疑，除了这句话，下面还有例子为证。可是今天 的一个bug引起的研究，我才发现这句话是错误的。</p><p>先从今天的bug说起的，mysqldb有一个bug，就是当mysql抛出error</p><blockquote><p>Lock wait timeout exceeded; try restarting transaction.</p></blockquote><p>mysqldb并不抛出异常，而是返回空的结果集。先放开mysqldb的bug，我想知道在我的代码中， 什么情况下会lock timeout。看了代码，我第一个猜测就是：是不是有些表项没有加索引， 导致使用了表锁，从而出项了lock timeout。接着查询资料：</p><ul><li>vairable: innodb_lock_wait_timeout。When a lock wait timeout occurs, the current statement is not executed. The current transaction is not rolled back. (Until MySQL 5.0.13 InnoDB rolled back the entire transaction if a lock wait timeout happened. ) ( from <a href="http://dev.mysql.com/doc/refman/5.0/en/innodb-parameters.html">InnoDB Startup Options and System Variables</a> )</li><li>variable: table_lock_wait_timeout. There is no lock wait timeout in MySQL&#8217;s table locks. (from <a href="http://dev.mysql.com/doc/refman/5.0/en/server-system-variables.html">Server System Variables</a> and <a href="http://bugs.mysql.com/bug.php?id=32005">bug</a>)</li></ul><p>从以上资料，可以看出，系统变量innodb_lock_wait_timeout就等待行锁释放的过期时间， 但是table_lock_wait_timeout早已经弃用。因此可以确定：就算没有使用索引，加了表锁， 也不会引起lock timeout。因为当加了表锁后，根本就会一直等待下去， 没有过期时间。接着就开始怀疑《mysql深入浅出》中这句话的正确性了。接着再看这些资料：</p><ul><li>Record locks always lock index records, even if a table is defined with no indexes. For such cases, InnoDB creates a hidden clustered index and uses this index for record locking. (from <a href="http://dev.mysql.com/doc/refman/5.0/en/innodb-record-level-locks.html">InnoDB Record, Gap, and Next-Key Locks</a>)</li></ul><p>如果你想知道，innodb是如何确定和定义clustered index，请点击<a href="http://dev.mysql.com/doc/refman/5.0/en/innodb-index-types.html">这里</a>。</p><p>现在基本明朗了：如果查询语句加锁，但是查询条件中没有索引， mysql innodb就会自动使用“隐藏的”聚集索引，当存在主键时， 这个主键就是这个表的聚集索引；如果存在NOT NULL的唯一键， 也可以作为聚集索引；但是以上情况都不存在，innodb就会组合各表项、 递增的row ID来定义一个主键。根本就不会加所谓的表锁。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2011/04/16/javascript-prototype/">JavaScript原型继承</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2011-04-16T00:00:00+08:00" pubdate data-updated="true">Apr 16<span>th</span>, 2011</time>
        
         | <a href="/blog/2011/04/16/javascript-prototype/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>以前对javascipt的原型也是很有了解的，很久以前发过一篇文章<a href="http://nextlinus.blog.163.com/blog/static/12200239820097543122796/">JavaScript原型继承</a>，谈了自己对原型继承的了解。
但是了解归了解，自己还没有真正写过一个子类继承一个超类，如果你认为下面的代码是继承，那就错了，那叫做“扩展”。</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
</pre></td>
  <td class="code"><pre><span class="comment">// Returns true if the last character is c</span>
String.prototype.<span class="function">endsWith</span> = <span class="keyword">function</span>(c) {
    <span class="keyword">return</span> (c == <span class="local-variable">this</span>.charAt(<span class="local-variable">this</span>.length - <span class="integer">1</span>))
}
</pre></td>
</tr></table>
</div>

<p>看过上段代码的同学，相信在代码附近也看到了warning：<strong>反对使用自己的方法来扩展内建类型</strong>。</p>

<p>在《Javascript权威指南》第五版一书中，列出了一个继承需要的步骤，或许读起来不是特别理解。那就从源头开始，看看为什么
继承一个父类需要什么步骤。我这里说的源头是”constructor”。</p>

<p>看看下段话，摘自《JavaScript权威指南》:</p>

<blockquote>
  <p>new操作符和构造函数，用来创建了一个新的对象，然后把构造函数作为这个对象的一个方法来调用。
除此之外，在创建这个空对象以后，new设置这个对象的原型。这个对象的原型就是构造函数的prototype
属性的值，并且这个prototype的初始化值是一个对象，只带有一个属性constructor，其值就是构造函数。</p>
</blockquote>

<p>根据上面一段话，就可以将</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre><span class="keyword">var</span> a = <span class="keyword">new</span> A();
</pre></td>
</tr></table>
</div>

<p>翻译成</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
</pre></td>
  <td class="code"><pre><span class="keyword">var</span> a = {}; A.call(a);
<span class="comment">/* If A inherit from object, A.prototype = new Object(); A.prototype.consturctor = A; */</span>
a.prototype = A.prototype;
</pre></td>
</tr></table>
</div>

<p>那如果想写一个子类B继承父类A，需要的步骤跟上面很类似:</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
</pre></td>
  <td class="code"><pre><span class="keyword">function</span> <span class="function">B</span>() {
    A.call(<span class="local-variable">this</span>);
    <span class="comment">/* other initialize code */</span>
}

B.prototype = <span class="keyword">new</span> A();
B.prototype.constructor = B;

<span class="comment">/* If need, delete some attribute you don't want to inherit */</span>
<span class="keyword">delete</span> B.prototype.xx;
</pre></td>
</tr></table>
</div>

<p>References &amp; Resources:</p>

<ul>
  <li>JavaScript权威指南</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/12/31/wifi-position/">网络(非GPS)定位原理</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-12-31T00:00:00+08:00" pubdate data-updated="true">Dec 31<span>st</span>, 2010</time>
        
         | <a href="/blog/2010/12/31/wifi-position/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>有次在地铁上，跟朱朝卓同学聊到这样一个话题，即可装13又省钱的方法：买个可以做3G 路由的廉价手机(比如华为U8500)，再买个ipod touch，用手机打电话和wifi热点，这样不到3000元就可以享受Apple产品，经济实惠！恩，的确是个很不错的途径！但是当时我有过顾虑：ipod touch使用wifi，LBS(物理定位服务)恐怕都用不成了，因为不能用GPS了嘛！但是朱朝卓告诉我是可以的，ucweb通过wifi可以定位！当时我的想法是，难道是通过ip定位？肯定很不准确吧？</p>
<p>今天中午，和双木成林同学聊天得知：用wifi定位，很准确，我还是觉得应该公司ip比较固定的缘故！但是双木成林接着说，在他家里定位也很准确！这就奇怪了，难道Google跟中国运营商有合作？这样需要满足以下条件才能定位：</p>
<ol>
<li>当用户连接网络时，运营商给用户分配地址的同时，同事记录了你的连接账号和分配ip的映射关系，通过用户的账号自然知道用户的地理位置，因为用户申请账号的时候都填写家庭或者公司地址</li>
<li>Google可以随时根据ip去访问运行商的接口获知详细地理位置。既然google都可以，那相关部门肯定也可以啊！</li>
</ol>
<p>如果真是这样，那就危险了？自己在任何地方，都没有隐私可言？被跨省也易如反掌啊！接着认真查看了<a href="http://code.google.com/p/gears/wiki/GeolocationAPI" target="_blank">Google Geolocaion API</a>，发现并不是这样！</p>
<blockquote>
<p>Many devices do not have native access to GPS or other location data. Additionally, GPS can take a long time to get an accurate location fix, drains battery, and does not work indoors. Because of these problems, the location API also has the ability to send various signals that the devices has access to (nearby cell sites, wifi nodes, etc) to a third-party location service provider, who can resolve the signals into a location estimate.</p>
</blockquote>
<p>大概的过程是这样的：Google是很大型的公司，每天都会分配很多工作人员到各城市满大街乱跑，去收集无线热点信息(包括cell sites和wifi nodes)，将那些固定、持久的无线热点以及地理信息保存到Google地理信息库中。当有浏览器或者应用程序请求地理信息时，会收集电脑或者手机附近的无线热点，发送给Google解析，从而获取详细的地址信息。</p>
<p>因此可以说，如果你的电脑或者手机没有无线设备或者禁用了无线设备，单凭ip是获取不到详细地理信息的！</p>
<p>测试：使用支持html5的浏览器(Firefox 或者 chrome)访问<a href="http://html5demos.com/geo">http://html5demos.com/geo</a>，点击&ldquo;允许&rdquo;浏览器跟踪您的地理信息，如果你当前打开了无线网卡，看看定位是否准确？我的电脑是台式机，不能定位，我让我女朋友测试，不知情的她说：我是特工。</p>
<p>References &amp; Resoucres:</p>
<ul>
<li><a href="http://code.google.com/p/gears/wiki/GeolocationAPI" target="_blank">Google Geolocaion API</a></li>
<li><a href="http://blog.2332.cn/archives/595" target="_blank">HTML5中的位置定位</a></li>
</ul>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/12/20/thinking-in-yield/">Thinking in Yield</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-12-20T00:00:00+08:00" pubdate data-updated="true">Dec 20<span>th</span>, 2010</time>
        
         | <a href="/blog/2010/12/20/thinking-in-yield/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>yield作为python的一个关键字，如果在函数体使用，那么这个调用这个函数返回一个“生成迭代器”(generator
iterator)，当然在平时都称呼为“生成器”。
为了更深入的了解生成器，还是先介绍下生成器有的特性和特点吧：</p>

<ul>
  <li>可以迭代（恩，这个特性是废话，从名字都可以看出来，但是这的确是生成器最基本的一个特性）</li>
  <li>通过调用next函数或者send函数（其实next() = send(None)
），会执行到yield语句，就会被冻结，冻结后就返回它的caller；直至调用下次send函数从上次冻结点接着执行</li>
  <li>当生成器对象引用计数为0被回收时，如果发现生成器对象仍然被冻结，就会调用close函数，close函数的作用就是抛出一个GeneratorExit的异常</li>
  <li>生成器只能被迭代一次（有点惊讶？我看源码的时候，发现这个的时候也有点）</li>
</ul>

<p>那generator是如何实现的呢？看了源码其实很简单，在初始化一个生成器对象，都需要一个参数:
PyFrameObject *
f。这个f就是生成器函数的栈帧，当函数被冻结时，记录这个栈帧的栈点stacktop
以及虚拟机字节码位置f_lasti。下次执行的时候直接从这个字节码位置和栈点执行。一切很简单吧！
一切谜底都要从python源码Python/ceval.c中的PyEval_EvalFrameEx开始，初始化代码：</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
</pre></td>
  <td class="code"><pre>    /* An explanation <span class="keyword">is</span> <span class="keyword">in</span> order <span class="keyword">for</span> the <span class="predefined">next</span> line.

       f-&gt;f_lasti now refers to the index of the last instruction
       executed.  You might think this was obvious <span class="keyword">from</span> <span class="include">the</span> <span class="include">name</span>, <span class="include">but</span>
       this wasn<span class="string"><span class="delimiter">'</span><span class="content">t always true before 2.3!  PyFrame_New now sets</span></span>
       f-&gt;f_lasti to -<span class="integer">1</span> (i.e. the index *before* the first instruction)
       <span class="keyword">and</span> YIELD_VALUE doesn<span class="string"><span class="delimiter">'</span><span class="content">t fiddle with f_lasti any more.  So this</span></span>
       does work.  Promise. */
    next_instr = first_instr + f-&gt;f_lasti + <span class="integer">1</span>;
    stack_pointer = f-&gt;f_stacktop;
    <span class="keyword">assert</span>(stack_pointer != NULL);
    f-&gt;f_stacktop = NULL;   /* remains NULL unless <span class="keyword">yield</span> suspends frame */
</pre></td>
</tr></table>
</div>

<p>那yield或者说生成器都有哪些应用呢：</p>

<ul>
  <li>生成迭代器(靠，又是废话)</li>
  <li>与with_statement结合使用</li>
  <li>著名的”Trampoline in python”</li>
  <li>轻量级任务</li>
  <li>其他……</li>
</ul>

<p>Resouces &amp; References:</p>

<ul>
  <li><a href="http://www.python.org/dev/peps/pep-0342/">The yield statement</a></li>
  <li><a href="http://www.python.org/dev/peps/pep-0342/">Coroutines via Enhanced Generators</a></li>
  <li><a href="http://www.python.org/dev/peps/pep-0343/">The with statement</a></li>
  <li><a href="http://knol.google.com/k/davy-wybiral/trampolining-in-python/23oi5sywhe2tp/2">Tramoplining in
python</a>(这个地方请看评论，我觉得评论比文章更为精彩)</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/12/14/git/">Git与svn的不同</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-12-14T00:00:00+08:00" pubdate data-updated="true">Dec 14<span>th</span>, 2010</time>
        
         | <a href="/blog/2010/12/14/git/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>以前写过一个blog：<a href="/?p=35001" target="_blank">Git初学习</a>，现在读来觉得当初对于git的理解真的很肤浅，现在就来说说git与svn的不同：</p>
<ul>
<li>分布式。这是git最明显的一个特征，分布式SCM。分布式也就要求，分布式中的每台机都保存了整个代码仓库所需要的所有代码和资源，而不仅仅是当前最新版本。分布式也带来很多好处：可以在离线的情况下版本控制；另外与集中式SCM不同，即使服务器挂掉也无妨，可以采用任何一台机进行恢复。</li>
<li>版本。svn的版本有着revision的概念，版本号是递增的。版本号能够递增，也是因为svn是集中式SCM的缘故。当多个用户同时提交时，svn服务器会将用户之间的提交操作串行。git是分布式SCM，没有递增的版本号，git采用的做法是：在保存到git之前，git将所有数据都要进行内容的校验和(checksum)计算，并将此结果作为数据的唯一标识和索引，作为版本号。</li>
<li>储存方式。svn每个版本提交时，保存的是当前版本与上个版本之间的diff。而git提交时，则是快照。比如git commit了文件A和B，则提交完成后，至少创建了5个对象，新的文件BLOB对象A和B；一个记录着目录树内容及其各个文件对应BLOB对象索引的tree对象；一个包含指向tree对象(根目录)的索引和其他提交信息元数据的commit对象。如果当前代码仓库还有文件C，由于文件C并没有修改，所以tree对象中保存的便是上个版本文件C的BLOB对象的索引。但是一旦文件被修改，比如A和B，就会创建一个新的BLOB文件对象，而不是仅仅的快照。git这种做法虽然牺牲了存储空间(现在存储空间很廉价的吧)，但是当比较两个版本或者合并分支的时候，速度上会有明显的提升。</li>
<li>真正的分支和tag。使用过svn都知道，svn中的分支和tag都是我们认为赋予的概念，都是通过svn copy复制到另外一个目录，通过目录或者人为命名标记为分支或者tag，并且人为的规定：tag是只读的，不能修改，而实际上可以修改的。而git则实现了真正的创建一个分支很简单，仅仅是创建一个branche对象，其中branche对象包含有指定commit对象的校验和(即版本号)，当随着开发的进行，提交新版本时，branche对象直接修改版本号即可。创建tag也是如此，新建一个tag对象，包含指定commit对象的校验和和其他数据信息。这也就是为什么在git下，创建分支和标签为什么这么快的根本原因。</li>
</ul>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/12/13/openvpn-autorun/">Openvpn随机启动并自动连接</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-12-13T00:00:00+08:00" pubdate data-updated="true">Dec 13<span>th</span>, 2010</time>
        
         | <a href="/blog/2010/12/13/openvpn-autorun/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在写这篇blog前，首先还得感谢郭嘉，因为Google App Engine
解封了，手机可以正常发推了，博客不用翻墙也可以登录了。</p>

<p>上周五一冲动还是买了一个ssh代理，虽然自己有个速度很快的免费openvpn，主要还是考虑：</p>

<ul>
  <li>vpn的确有着自身的一些软肋：所有境外ip都要走vpn，启动需要手动输入账号密码，修改route比较麻烦</li>
  <li>免费申请的openvpn规定不能观看youtube，虽然在技术上并没有做任何限制，但是由于免费申请来的，自己经常看，也不好意思</li>
  <li>上周五，免费申请的openvpn突然不给力了，速度突然慢起来</li>
  <li>自己免费申请的openvpn速度都很赞，想着如果自己买个岂不是更快</li>
</ul>

<p>所以就在<a href="https://tuite.im">敏感词</a>上的<a href="http://www.fishnote.net/?page_id=276">ssh广告</a>买了一个“45元/366天规格“的ssh服务，当时测试下载速度很快，500kb/s左右，在账号为到之前，我觉得用了这个ssh代理会秒开twitter，facebook，流畅观看youtube。晚上做梦的时候还是翻墙。</p>

<p>可是第二天账号到的时候，才发现自己错了，购买的ssh代理服务只是比gappproxy快点而已，没有自己免费申请的openvpn，开始还以为是自己的客户端软件myEnTunnel的plink核心做了限速，谁知修复了这个问题或者换了Tunnerler都不管用，现在我才意识到下载测试速度跟真是翻墙代理的速度不是一个概念，很有可能是代理服务器对账号做了限速。自己不得不换回免费申请的openvpn。</p>

<p>使用openvpn时，觉得有几点不爽：</p>

<ul>
  <li>每次都要手动输入账号密码，官方认为将账号和密码保存起来不太安全</li>
  <li>不能自动连接，虽然可以随机启动</li>
</ul>

<p>上网google了下，果然得到了解决。</p>

<p>首先说在windows下，虽然官方没有推出保存保存账号和密码的openvpn-GUI版本，但是已经有人为了方便，自己修改了openvpn源码，重新编译好了，供我们<a href="http://blog.chinaunix.net/u/2389/upfile/060414190738.rar">下载</a>。使用起来也很方便，直接将client.ovpn中的auth-user-pass改成auth-user-pass
mypass.pwd即可。其中mypass.pwd是保存着账号密码的文件，第一行为账号，第二行为密码。在windows下系统启动并自动连接，直接修改注册表即可，即：</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
</pre></td>
  <td class="code"><pre>[HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindowsCurrentVersionRun]
$OPENVPN_PATH --connect client.ovpn --sclient-connection 1
</pre></td>
</tr></table>
</div>

<p>在ubuntu下，随机启动并且自动连接也很简单，也是跟上面一样修改clien.ovpn中的auth-user-pass，但是需要在编译安装openvpn的时候，需要指定enable-user-pass。不过幸运的是，如果你采用sudo
apt-get install openvpn，已经默认支持保存账户密码了。</p>

<p>Resources &amp; References:</p>

<ul>
  <li><a href="http://www.lostinbeijing.com/2010/04/openvpn-autostart-and-auto-connect/">openvpn自动启动自动连接</a></li>
  <li>[可以把用户名/密码保存到文件的OpenVPN程序–<a href="http://blog.chinaunix.net/u/2389/upfile/060414190738.rar">下载</a>][]</li>
</ul>

<p>[可以把用户名/密码保存到文件的OpenVPN程序–<a href="http://blog.chinaunix.net/u/2389/upfile/060414190738.rar">下载</a>]: http://blog.chinaunix.net/u/2389/showart_67269.html</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/3/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/08/18/rm-daemon-log/">删除守护进程的日志</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/18/cpickle-regex-object/">cPickle正则表达式对象</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/06/11/tcp-time-wait/">深入理解TCP的TIME-WAIT</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/04/28/epoll-emfile/">epoll由EMFILE引发CPU飙升</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/03/24/tcp-keepalive/">细聊TCP的KeepAlive</a>
      </li>
    
  </ul>
</section>






  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Yang Juven -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/lucaslew/whitespace">Whitespace</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'qiusuo';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>














</body>
</html>
