
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>On the road</title>
  <meta name="author" content="Yang Juven">

  
  <meta name="description" content="　　前天下午参加了珠三角技术沙龙2010Q4，对陈硕老师(@bnu_chensuo)讲的分布式系统的工程化开发方法很是感兴趣，也觉得陈硕老师讲的很入理，虽然我对分布式仅仅处于了解阶段，对于网络编程更是一窍不通。下面就谈谈通过这堂课，我的收获：分布式的场景：几十到几百台PC分布式的状况： &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://yangjuven.github.com/blog/page/3">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="On the road" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Fjalla+One' rel='stylesheet' type='text/css'>
  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-31079582-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   class="collapse-sidebar sidebar-footer" >
  <header role="banner"><hgroup>
  <h1><a href="/">On the road</a></h1>
  
    <h2>求索路上⋯⋯</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:yangjuven.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/10/19/distribute-system/">分布式系统工程化</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-10-19T00:00:00+08:00" pubdate data-updated="true">Oct 19<span>th</span>, 2010</time>
        
         | <a href="/blog/2010/10/19/distribute-system/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>　　前天下午参加了<a href="http://techparty.org/2010/09/14/techparty-6-start/" target="_blank"><span style="color:#000000;">珠三角技术沙龙2010Q4</span></a>，对陈硕老师(<a href="http://twitter.com/#!/bnu_chenshuo"><span style="color:#000000;">@bnu_chensuo</span></a>)讲的<a href="http://blog.csdn.net/Solstice/archive/2010/10/19/5950190.aspx"><span style="color:#000000;">分布式系统的工程化开发方法</span></a>很是感兴趣，也觉得陈硕老师讲的很入理，虽然我对分布式仅仅处于了解阶段，对于网络编程更是一窍不通。下面就谈谈通过这堂课，我的收获：</p><p></p><ul><li>分布式的场景：几十到几百台PC</li><li>分布式的状况：还处于技术浪潮的前期，没有公认的成熟解决方案，虽有些开源组件但是可靠性有待考虑</li><li>分布式的实现技术：勿在浮沙建高台，要是用成熟的技术，借鉴但不是照搬别人的“成功经验”</li><li>分布式的设计原则：Desgin For Failure，高可用的关键在于不停机，恰恰在于可以随时重启。</li><li>分布式需要实现监控：程序内置Naming Service，对各种异常报警，让人来处理</li><li>分布式进程通信：为了能实现重启，所以只是用操作系统能自动回收的IPC(TCP)，不用生命期大于进程的IPC(共享内存，mutex)，不使用不能重建的IPC(pipe)</li><li>心跳协议的设计：进程c依赖进程S，则进程S向进程C发送心跳(什么是依赖？为何这样？我还没有搞懂)；不要另起线程发送心跳包，直接在工作线程发送，避免假心跳</li><li>消息格式的设计：要想着以后的升级和兼容，不要用C struct或者bit fileds，考虑Google Protocal Buffer</li></ul><p></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/10/17/python-source-code/">Python源码初探</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-10-17T00:00:00+08:00" pubdate data-updated="true">Oct 17<span>th</span>, 2010</time>
        
         | <a href="/blog/2010/10/17/python-source-code/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在阅读完《Apanche源代码全景分析》前6章后，对Apache体系结构以及模块开发有了比较深的认识，也开发了一个比较简单的Module(实现pv统计，用memcached保存page
count，<a href="http://github.com/yangjuven/mod_pv_count">源代码链接</a>)，最近开始了新的阅读《python源码剖析》。在阅读完前3章(python对象初探，PyIntObject，PyStringObject)，终于揭开python神秘的面纱，拉近我和python之间的距离。</p>

<p>python中一切皆对象，而对象机制的基石便是PyObject</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
</pre></td>
  <td class="code"><pre>typedef struct _object {
    <span class="predefined">int</span> ob_refcnt;
    struct _typeobject *ob_type;
}PyObject;
</pre></td>
</tr></table>
</div>

<p>ob_refcnt便是引用计数，ob_type便是类型信息。那么其他对象都可以在此基础上扩展，添加自身的信息，比如</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
</pre></td>
  <td class="code"><pre>typedef struct _object {
     <span class="predefined">int</span> ob_refcnt;
     struct _typeobject *ob_type;
     <span class="predefined">long</span> ob_ival;
}PyIntObject;
</pre></td>
</tr></table>
</div>

<p>当时阅读到这里，最疑惑的是python中的类型对象和实例对象都是怎么实现？stuct
PyTypeObject的一个实例PyType_Type便是类型对象的基础，所有类型对象的ob_type都是指向PyType_Type，包括PyType_type本身，也就是说下面的表达式是成立的：</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre>PyType_Type-&gt;ob_type == &amp;PyType_Type
</pre></td>
</tr></table>
</div>

<p>一切很简单，比如</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre>a = <span class="integer">1</span>
</pre></td>
</tr></table>
</div>

<p>a是一个int类型，a便是struct
PyIntObject数据，int便是PyInt_Type(PyInt_type并不是一个struct，也是一个struct
PyTypeObject数据)。这便是python中“一切皆对象”的完美实现。</p>

<p>另外，还有几点说明，需要警惕下：</p>

<ul>
  <li>在python的各种对象中，类型对象时超越引用计数的。类型对象“跳出三界外，不在五行中”，永远不会被析构。每个对象中指向类型对象的指针不会被视为类型对象的引用，就是说每个对象建立初始化化，并不会对类型对象的引用计数加一；销毁时并不会减一。估计类型对象的引用计数永远是1了。</li>
  <li>在python中，PyIntObject和PyStringObject都引用了内存对象池，因为对于这些用经常频繁用到的数据，会有大量的时间浪费是内存的申请和销毁上(如果不适用内存对象池的话)。PyIntObject不仅使用了小整数对象池(范围从NSMALLNEGINTS到NSAMLLPOSINTS)，还有专门的PyIntBlock来用于申请大整数对象。因此对于一个整数，在NSAMLLNEGINTS和NSMALLPOSINTS之间，如果数值相等，其id便是相等，但是其他的id就不同了。PyStringObject也有字符串内存池，对于size为0或者1的字符串，都会经过intern机制缓存起来，其id肯定相同，但是大于1的就不一定了，这个或许跟创建PyStrngObject采用的方法有关吧，有可能是PySting_FromString，PyString_InternInPlace，也有可能是PyString_InternFromString。</li>
  <li>关于PyStringObject的一个效率问题。对于N个字符串的连接，如果采用直接相加的话，调用string_concat，就会有N-1的内存申请以及内存搬运工作。但是如果采用”“.join([a, b, ..]的话，调用string_join，在开始时会一次性计算好内存，然后申请内存，将字符串拼接，生成PyStringObject即可。</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/07/05/python-memcached/">Python-memcached连接维护</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-07-05T00:00:00+08:00" pubdate data-updated="true">Jul 5<span>th</span>, 2010</time>
        
         | <a href="/blog/2010/07/05/python-memcached/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>纵所周知，memcahced client管理了多个与服务器的连接，实现分布式缓存系统。那我们需要担心的是，在执行相关操作时，如果连接断开会出现什么结果？</p>
<p>阅读了python-memcached源码，它是这样处理的：当缓存或者读取数据的时候，连接断开，出现socket.error，client daemon就会标记该连接为dead，在30秒内，不会重新连接。需要注意的是，当出现socket&nbsp;error，除了相关处理外，client daemon并不会抛出错误，仅仅将该次error输出到标准错误，执行相关命名的返回结果也是None或者0(有就是执行失败)。</p>
<div>
<div>对于此种处理，我认为是合理的。因为毕竟memcached是缓存，而不是持久化存储，它并不保证你的每次操作(或者说命令)在没有报错的情况下，一定是成功的。</div>
</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/07/05/memcached-stufy/">Memcached初学习</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-07-05T00:00:00+08:00" pubdate data-updated="true">Jul 5<span>th</span>, 2010</time>
        
         | <a href="/blog/2010/07/05/memcached-stufy/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>许多web应用都是将数据保存在RDBMS中，web apps从RDMS中读取数据并经过渲染后返回给客户端，在浏览器中显示。但是随着数据访问量的增大，访问的集中，RDBMS的负担加重，响应速度变慢、显示延迟等问题都会出现。</p>
<p>但是如果我们采取以下做法：每次从RDBMS读取的数据存放在内存中，并且更新内容时，不仅更改RDBMS并且同时更改内存中的数据。那么等待用户下次读取数据时，先从内存中获取，如果存在直接返回，如果没有再从RDBMS获取返回。</p>
<p>采取这种做法，响应速度就会得到很大改善。因为磁盘I/O的速度跟内存的读写速度不是一个等级的。</p>
<p>memcached是一个实现以上做法的、高性能、分布式的内存对象缓存系统，目的主要是通过减轻数据库负载来使动态web应用程序提速，任意的数据都是采用key-value形式存储的。</p>
<h2>1. memcached特点</h2>
<div>
<h3>1.1 协议简单</h3>
<div>采用简单的基于文本行的协议，并没有采用二进制协议或者复杂的XML格式。(目前memcahed开发者们正在策划和实现二进制协议)</div>
<h3>1.2 基于libevent的事件处理</h3>
<div>使用libevent取代了网络服务器所使用的循环检查架构，从而可以省去对网络的处理，达到不错的性能。(参考 对于此点优势，了解还不是特别深入)</div>
<h3>1.3 内置内存存储方式</h3>
<div>为了提高性能，memcached都将数据保存在内存中。因此如果重启memcahed、重启操作系统或者断电等操作都会造成数据的丢失。所以说memcached不能永久存储数据。</div>
<h3>1.4 memcached不互相通信的分布式</h3>
<div>memcached虽然是分布式缓存服务器，但是服务端并没有分布式功能，分布式读和写都由客户端采用特定的算法去实现。另外，服务器端并不会通信以达到共享信息。我的看法是：memcached是个缓存系统，并不需要像NoSQL达到&ldquo;最终一致性&rdquo;，所以每个服务器保存的内容都是不一样的，都只是部分数据。另外如果一个服务器出现异常，也不影响正常程序，因为我们丢失的仅仅是&ldquo;缓存&rdquo;数据。</div>
</div>
<div></div>
<div>
<h2>2 实现memcached的相关理论和方式</h2>
</div>
<div>
<h3>2.1 内存存储方式</h3>
<p>在使用内存存储数据的时候，就涉及到如何分配内存。如果采用简单的malloc和free，就会导致内存碎片，反而会加重操作系统管理内存的负担。而memcached采用的内存分配机制Slab Allocation，就是为了解决这种问题。具体的工作原理是：按照预先设定的大小，将内存分割成特定长度的块，并且把长度相同的块分成组；这些内存并不会释放，而是重复利用。memcached根据客户端发来数据的大小去选择合适的块去保存，然后将数据缓存其中。</p>
<div>Slab Allocation解决了内存碎片的问题，但是却带来了另外一个问题：由于分配块的大小是固定大小，而客户端发来缓存的数据大小却是随机的，就会造成内存浪费的问题，比如一个100k的数据保存一个128k大小的块中，造成了28k内存空间的浪费。对于这个问题还没有良好的解决方案。但是如果预先知道客户端发送的数据的公用大小，或者仅缓存大小相同的情况下，只要使用适合数据大小的组的列表，就可以减小浪费。</div>
<h3>2.2 删除缓存数据方式</h3>
<div>内存空间不是无限的，当然有个上限或者一个指定值，所以删除缓存数据是必须的。memcached采用的方式是：LRU(Least Recently Used)，也就是说：当memcached内存容量达到指定值后，需要空间来缓存新的数据时，去删除那些近期最少使用的数据，用它的内存空间来保存新的缓存数据。</div>
<h3>2.3 客户端分布式算法</h3>
<p>memcached分服务端和客户端，服务端仅仅负责存储和读取。至于分布式存储，是客户端需要做的事情。分布式存储，需要保证实现一个特性：良好的伸缩性和扩展性，我对此特性的理解就是：在memcached服务器中，如果新添一台服务器，简简单单通过配置就可以，而不影响其他服务器的正常运行，缓存数据的键也会均匀分散到各个服务器；如果一台memcached服务器因为故障无法连接，也不会影响其他缓存，系统依然能继续运行。</p>
<p>下面就简单介绍下实现该特性比较完善的算法：Consistent Hashing，nosql中需要实现分布的数据库也多采用这种算法。其基本原理是：首先计算各个服务器的哈希值，并将其配置到0 ~ 2^32 的圆上(不是线段哦)，然后采用同样的方法求出数据的键的哈希值，映射到圆上，沿着映射的位置顺时针查找，将数据保存在最近的一个服务器上。如果超过2^32任然找不到，就保存到第一台服务器上。读取数据时，也是同样的道理，计算读取数据的键的哈希值，根据哈希值找到对应服务器，读取值。</p>
<div>采取此种算法的好处就是，不管添加服务器或者减少服务器或者服务器故障，都不会影响缓存数据，不影响系统的正常运行。并且，如果我们让一个服务器(物理节点)对应n个虚拟节点，随机分布在0 ~ 2^32的圆上，这样就可以解决分布数据不均匀的问题。</div>
</div>
<p>&nbsp;</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/07/05/memcached-and-iptables/">Memcached与iptables</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-07-05T00:00:00+08:00" pubdate data-updated="true">Jul 5<span>th</span>, 2010</time>
        
         | <a href="/blog/2010/07/05/memcached-and-iptables/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在客户端去连接memcached的服务端，很简单，一个tcp或者udp连接，不需要user和password。貌似很简单，很容易维护，没有了管理帐户的麻烦，但是很不安全。因为如果不加限制，任何一台计算机通过telnet ip port都可以访问memcached服务器，访问和修改数据。这是，就需要iptables对访问加以限制。</p>
<p>什么是iptables(<a href="http://www.netfilter.org/projects/iptables/index.html" target="_blank">官网</a>)?iptables is the userspace command line program used to configure the Linux 2.4.x and 2.6.x IPv4 packet filtering ruleset. It is targeted towards system administrators. 我认为iptables就是计算机网络数据进出的一个负责人或者说一个门卫，对任何一个数据包，根据数据包的执行阶段(chain)和相关操作(table)，执行相关的策略(target)，当然需要对数据包进行一定的筛选，可以根据协议(protocal)、端口(port)、地址(ip)、数据包(state)状态等等去判断。</p>
<p>至于这些筛选规则和相关策略都可以设置，但是首先你必须是root。可以通过iptables或者iptables-restore去设置，也可以通过iptables-save或者iptables -L去查看当前的设置。(PS: 如果当前没有设置过规则，使用iptables-save是会报错的，<span style="color:#ff0000;">iptables-save v1.4.2: Unable to open /proc/net/ip_tables_names: No such file or directory</span>)</p>
<p>通过这次也终于搞明白了unix中经常提到的bind是何意？一台电脑是可以有多个ip的，比如123.0.0.1和x.x.x.x，在启动memcached的时候，可以bind到其中一个ip。客户端访问时，就必须访问服务器端绑定的ip，不然就会访问出错。</p>
<p>Resoures &amp; References:</p>
<ol>
<li><a href="http://www.netfilter.org/projects/iptables/index.html" target="_blank">netfiler</a></li>
<li><a href="http://book.51cto.com/art/200904/120839.htm">iptables-save与iptables-restore</a></li>
<li><a href="http://man.chinaunix.net/network/iptables-tutorial-cn-1.1.19.html#OTHERRESOURCES" target="_blank">iptables指南</a></li>
</ol>
<p>&nbsp;</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/07/05/get-safe-remote-addr/">安全有效获取客户端IP</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-07-05T00:00:00+08:00" pubdate data-updated="true">Jul 5<span>th</span>, 2010</time>
        
         | <a href="/blog/2010/07/05/get-safe-remote-addr/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在web开发中，经常需要获取用户的ip地址，以便记录或者添加特定的限制。但是实际生产环境中，web server使用了代理服务器，所以environ中remote_addr的ip地址通常是离web server最近一层代理服务器的ip地址，这样得到的ip就没有太大的意义。但是x-forwarded-for的出现就是想解决这种问题，但是这种方式如何使用以及可靠性如何，都是我们应该考虑的范畴。下面就具体讨论下关于x-forwarded-for和remote_addr的区别。</p>
<h3>1. 含义不同</h3>
<p>The REMOTE_ADDR variable MUST be set to the network address of the client sending the request to the server.(参考RFC3875 4.1.8 REMOTE_ADDR)</p>
<div>The X-Forwarded-For (XFF) HTTP header is a de facto standard for identifying the originating IP&nbsp;address of a client connecting to a web server through an HTTP proxy or load balancer. This is a non-RFC-standard request header which was introduced by the Squid caching proxy server&#8217;s developers.(<a href="http://en.wikipedia.org/wiki/X-Forwarded-For" target="_blank">参考</a>)</div>
<h3>2. 格式不同</h3>
<p>remote_addr的值就是单个ip地址，而x-forwarded-for则是多个ip地址的集合：</p>
<div>The general format of the header is:</div>
<div>X-Forwarded-For: client1, proxy1, proxy2</div>
<div>where the value is a comma+space separated list of IP addresses, the left-most being the farthest&nbsp;downstream client, and each successive proxy that passed the request adding the IP address where it&nbsp;received the request from. In this example, the request passed proxy1, proxy2 and proxy3 (proxy3&nbsp;appears as remote address of the request).(<a href="http://en.wikipedia.org/wiki/X-Forwarded-For#format" target="_blank">参考</a>)</div>
<h3>3. 来源不同</h3>
<p>remote_addr是http server与客户端通过三次握手建立的tcp连接后，根据socket中的ip赋值给remote_addr。而x-forwarded-for则是http server解析http报文头部获取的。</p>
<p>&nbsp;</p>
<div>总结：通过来源不同，可以看出，environ中的remote_addr是很不容易伪造的，但是x-forwarded-for则相反，极易伪造，伪造一个http 报文头部，轻而易举。所以我们不能简单通过获取x-forwarded-for的ip地址列中的第一项作为客户端ip地址。但是由于代理服务器是我们部署的，这个是可信的，所以x-forwarded-for的内容，我们不能&ldquo;全信&rdquo;，也不能&ldquo;全不信&rdquo;。至少经过我们的代理服务器，在x-forwarded-for上添加的ip是可信的，所以我们可以通过实际生产环境部署的代理服务器情况，也从x-forwarded-for中选择合适的ip。比如我们只有一层代理服务器，那么x-forwarded-for的最后一个ip就是客户端ip，并且是&ldquo;可信&rdquo;的，因为这个ip是代理服务器根据客户端ip加上去的。</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/07/03/init-py/">神秘的__init__.py</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-07-03T00:00:00+08:00" pubdate data-updated="true">Jul 3<span>rd</span>, 2010</time>
        
         | <a href="/blog/2010/07/03/init-py/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>Python中的module和package的作用不言而喻：Each module has its own private
symbol table, which is used as the global symbol table by all functions
defined in the module. Thus, the author of a module can use global
variables in the module without worrying about accidental clashes with a
user’s global variables.而Packages are a way of structuring Python’s
module namespace by using “dotted module names”.</p>

<p>让package称为module那样的访问，__init__ .py
。一个文件夹A如果存在文件__init__.py(哪怕这个文件夹是空的)，就表明A不是一个简简单单的文件夹，而是一个包。</p>

<p>另外__init__.py控制着包的导入行为。比如现在存在这样一个pacakge：</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
<a href="#n11" name="n11">11</a>
<a href="#n12" name="n12">12</a>
<a href="#n13" name="n13">13</a>
</pre></td>
  <td class="code"><pre>Package1/

__init__.py

Module1.py

Module2.py

Package2/ __init__.py

Module1.py

Module2.py
</pre></td>
</tr></table>
</div>

<p>如果执行语句：</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">Package1</span>
Package1.Module1
</pre></td>
</tr></table>
</div>

<p>肯定会报错</p>

<p>AttributeError: ‘module’ object has no attribute ‘Module1’</p>

<p>为何？因为Module1只是Package1的一个submodule，并不是attribute，通过dir(package)就可以看出。如果想执行正确上面的语句，就必须在__init__.py中执行：</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre><span class="keyword">import</span> <span class="include">Module1</span>
</pre></td>
</tr></table>
</div>

<p>另外，语句</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre><span class="keyword">from</span> <span class="include">Package1</span> <span class="keyword">import</span> <span class="include">*</span>
</pre></td>
</tr></table>
</div>

<p>到底import了那些，完全依靠__init__.py中的__all__属性。</p>

<p>另外，关于from和import需要注意的是：</p>

<blockquote>
  <p>Note that when using from package import item, the item can be either
a submodule (or subpackage) of the package, or some other name defined
in the package, like a function, class or variable. The import
statement first tests whether the item is defined in the package; if
not, it assumes it is a module and attempts to load it. If it fails to
find it, an ImportError exception is raised.</p>

  <p>Contrarily, when using syntax like import item.subitem.subsubitem,
each item except for the last must be a package; the last item can be
a module or a package but can’t be a class or function or variable
defined in the previous item.</p>
</blockquote>

<p>Resouces &amp; References</p>

<ol>
  <li><a href="http://docs.python.org/tutorial/modules.html">Modules</a></li>
  <li><a href="http://www.yuanma.org/data/2008/1229/article_3456.htm">Python模块包中__init__.py文件的作用</a></li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/07/03/encoding-error/">又遇乱码</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-07-03T00:00:00+08:00" pubdate data-updated="true">Jul 3<span>rd</span>, 2010</time>
        
         | <a href="/blog/2010/07/03/encoding-error/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>身为一个Chinese Web
Coder，最烦也最不可避免的就是乱码。在解决乱码之前，必须搞清楚unicode和编码方式的区别，python中执行环境的默认编码。</p>

<p>unicode的诞生就是要显示世界上不同国家、不同地区的文字。它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。在我看来，unicode就是一个简单的映射表，key是二进制编码，value就是各个语言的不同字符。而如何高效保存和读取这些二进制编码，就是编码方式所要解决的方法，不同编码方式有着不同的保存读取方式。</p>

<p>在python命令行解释器中：</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
</pre></td>
  <td class="code"><pre>&gt;&gt;&gt; s = <span class="string"><span class="delimiter">&quot;</span><span class="content">中国</span><span class="delimiter">&quot;</span></span>
&gt;&gt;&gt; s
<span class="string"><span class="delimiter">'</span><span class="content">xd6xd0xb9xfa</span><span class="delimiter">'</span></span>
</pre></td>
</tr></table>
</div>

<p>我的理解就是，”中”和”国”两个字的unicode码按照python默认的编码方式保存起来了。至于默认编码方式是多少，是sys.getdefaultencoding()或者sys.getfilesystemencoding()。至于这两个的区别：</p>

<ul>
  <li>sys.getdefaultencoding(). Return the name of the current default
string encoding used by the Unicode implementation. New in version
2.0.</li>
  <li>sys.getfilesystemencoding(). Return the name of the encoding used to
convert Unicode filenames into system file names, or None if the
system default encoding is used.</li>
</ul>

<p>到底用的哪个，我到现在还没有搞清。按照解释，应该是sys.getdefaultencoding()，但是实际测试却是sys.getfilesystemencoding()。</p>

<p>但是在文件中，却有另外一番理论。在文件中，我们需要关心两个编码：文件自身保存的编码以及我们在开始设置的coding。</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre><span class="comment">#! -*- coding: utf-8 -*-</span>
</pre></td>
</tr></table>
</div>

<p>With that declaration, all characters in the source file will be treated
as having the encoding encoding, and it will be possible to directly
write Unicode string literals in the selected encoding. The list of
possible encodings can be found in the Python Library Reference, in the
section on codecs.</p>

<p>文件中如果字符串中有汉字，其对应值是以文件保存编码方式编码，因此如果开始设置的coding跟文件保存编码不一样，用设置的coding去解码时，自然会报错。因此让两种编码保证一致，是很有必要的。</p>

<p>Resoucres &amp; References</p>

<ol>
  <li><a href="http://docs.python.org/tutorial/interpreter.html">Using the Python Interpreter</a></li>
  <li>python -&gt; docs-pdf -&gt; library.pdf</li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/06/25/love/">追忆年华</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-06-25T00:00:00+08:00" pubdate data-updated="true">Jun 25<span>th</span>, 2010</time>
        
         | <a href="/blog/2010/06/25/love/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>四年前，德国世界杯如火如荼的进行着。当时我跟茹茹的关系，可以用茹茹的一句经典的话来概括：当时谁认识你啊！月上柳 &nbsp; 梢头，人约黄昏后，我们游走于三教和荟园开水房之间的大道，探讨着&ldquo;我喜欢你，你为什么不喜欢我？你怎么样才能喜欢我 ，做我女朋友&rdquo;的神圣话题。那时，世界杯的激情，似乎跟我们没有关系。</p>
<p>四年后，南非世界杯也同样如火如荼的举行着。现在，我和茹茹早已相知相爱，我们已经相互理解，我们的性格经过四年的磨合，对于大事上的看法也慢慢趋于一致。可以说，我们现在的人生观、价值观、世界观已经归拢。 &nbsp; &nbsp;</p>
<p>四年，人生最重要的四年，已经过去。这四年，包含着多少美好记忆，承载着许多酸甜苦辣，孕育了我们的爱情，催生了我的日渐成熟。这四年来，我是幸运的，我是成功的。幸运的遇到了人生中的另一半，成功的俘获了她的芳心。</p>
<div>我们拥有令旁人羡慕，自己永生难忘的甜蜜时光：</div>
<div>
<ul>
<li>月光下散步，大学生活动中心前的竹林、南湖边有我们的身影</li>
<li>春天，学校油菜花开了，那黄灿灿的油菜花，加上我们是多么的美丽</li>
<li>南湖边，桃花园，散步感受春意</li>
<li>夏天热了，在草地买个西瓜，跟茹茹品尝</li>
<li>在体育馆前的林荫小道，学习、聊天、休息</li>
<li>篮球场上、一运，当茹茹想保持身材的时候，我们也会在这里滴下汗水</li>
<li>荟一楼下的草地，有多少等待在那里</li>
<li>游泳馆游泳，虽然只有一次，虽然我不会，但是有茹茹的陪伴，一次足以记忆一生</li>
<li>冬天满天雪花，打雪仗自然少不了我们</li>
<li>茹茹的21岁生日，野芷湖旁，我们将21根蜡烛组成心形</li>
<li>我们经常出去吃小吃，常去校门口、司门口、中南财大，酸辣粉、周黑鸭、肉夹馍、馄饨&hellip;&hellip;</li>
<li>动物园、磨山、江滩，有着心爱的人，游玩的感觉无法形容</li>
<li>我头痛时，茹茹越来越唠叨，越来越像我妈时，我知道那是关心体贴</li>
<li>工作了，一到周末，茹茹屁颠屁颠过来找我</li>
<li>不管在学校，还是在广州，虽然我不喜欢逛街，虽然我当时都很不耐烦，但是现在回忆，依然很美好</li>
<li>&hellip;&hellip;</li>
</ul>
<p>当然我们也经常吵架，我们也有不合，茹茹也经常对我的举动不满意，虽然我们争吵很多，虽然我们有时候争取很凶，但是我们通过争吵更加了解对方。我依然记得在雪地里，茹茹咬着牙，使出浑身力气，将她的粉拳细腿砸向我，但我更记得我们第二天和好时的甜蜜。</p>
<p>虽然我现在不富裕，但我坚信：我能够给茹茹快乐幸福的生活。就像电视剧《媳妇的美好时代》里，余味反驳李若秋一样：&ldquo;我跟豆豆的生活乐趣，是我们通过自己的努力，共同买辆车，我们这个月在一块存钱，能够买一个车轮子，下个月在存钱就买了方向盘，再下个月我们就买了后备箱，再下个月我们就买了一辆车了，也可能车的钱，不贵，很便宜，只是一辆QQ，这个车就全当练手了，练会了之后，随着以后越来越好，我们会买更好的车，这就是我们两人的快乐。&rdquo;我想这也是我应该给茹茹的快乐，并且是我能够给茹茹的幸福。</p>
</div>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2010/06/23/python-sorted/">排序</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2010-06-23T00:00:00+08:00" pubdate data-updated="true">Jun 23<span>rd</span>, 2010</time>
        
         | <a href="/blog/2010/06/23/python-sorted/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在平时项目中，排序很常见，一般情况下，采取的常见方法有：</p>

<ul>
  <li>在数据库查询时order by xx。</li>
  <li>采用list的方法sort(), 如list.sort()</li>
</ul>

<p>但是有写情况，上面两种情况不是那么轻易可以搞定的。内建函数sorted则相当强大。</p>

<p>sorted(iterable, cmp=None, key=None, reverse=False)：</p>

<ul>
  <li>iterable是一个可迭代的对象，就是我们需要排序的对象</li>
  <li>cmp只是一个函数，定义了两个元素之间的比较规则。如果这个参数为None，则按照程序默认的排序规则比较iterable的元素对象。如果不为None，则根据cmp来比较。</li>
  <li>key也是一个函数，但是这个函数和cmp不同，key函数是用来提取iterable对象元素的索引，用这个索引来排序。如果key为None，则直接用iterable对象元素来排序。</li>
  <li>reverse则是指定排序的顺序，如果为False，则从小到大，为True，则从大到小，默认为False。</li>
</ul>

<p>比如现在有这样一个list：</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
</pre></td>
  <td class="code"><pre>user = [
    {<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">Juven</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>: <span class="integer">23</span>},
    {<span class="string"><span class="delimiter">&quot;</span><span class="content">name</span><span class="delimiter">&quot;</span></span>: <span class="string"><span class="delimiter">&quot;</span><span class="content">fisher</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>: <span class="integer">22</span>}
]
</pre></td>
</tr></table>
</div>

<p>想根据age来降序排序，怎样做呢？一句话搞定：</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre><span class="predefined">sorted</span>(user, key=operation.itemgetter(<span class="string"><span class="delimiter">&quot;</span><span class="content">age</span><span class="delimiter">&quot;</span></span>), reverse=<span class="predefined-constant">True</span>)
</pre></td>
</tr></table>
</div>

<p>或许你对itemgetter不熟，看看这些：</p>

<p>itemgetter(item, [args…])</p>

<p>Return a callable object that fetches item from its operand using the
operand’s __getitem__() method.</p>

<p>If multiple items are specified, returns a tuple of lookup values.</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/4/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/2/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/03/19/tcp-timeout/">TCP协议的那些超时</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/03/15/udp-server-bind-all-interfaces/">UDP server绑定IP到INADDR_ANY？</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/03/15/start-stop-daemon-usage/">用start-stop-daemon将程序变为守护进程</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/02/06/differences-between-jquery-bind-vs-live-vs-delegate-vs-on/">jQuery事件绑定bind,delegate,live,on比较</a>
      </li>
    
      <li class="post">
        <a href="/blog/2011/07/25/web-cache/">Web缓存</a>
      </li>
    
  </ul>
</section>






  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Yang Juven -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a> | Themed with <a href="https://github.com/lucaslew/whitespace">Whitespace</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'qiusuo';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>














</body>
</html>
