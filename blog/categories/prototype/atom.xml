<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: prototype | On the road]]></title>
  <link href="http://yangjuven.github.com/blog/categories/prototype/atom.xml" rel="self"/>
  <link href="http://yangjuven.github.com/"/>
  <updated>2014-04-28T08:17:59+08:00</updated>
  <id>http://yangjuven.github.com/</id>
  <author>
    <name><![CDATA[Yang Juven]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[JavaScript原型继承]]></title>
    <link href="http://yangjuven.github.com/blog/2011/04/16/javascript-prototype/"/>
    <updated>2011-04-16T00:00:00+08:00</updated>
    <id>http://yangjuven.github.com/blog/2011/04/16/javascript-prototype</id>
    <content type="html"><![CDATA[<p>以前对javascipt的原型也是很有了解的，很久以前发过一篇文章<a href="http://nextlinus.blog.163.com/blog/static/12200239820097543122796/">JavaScript原型继承</a>，谈了自己对原型继承的了解。
但是了解归了解，自己还没有真正写过一个子类继承一个超类，如果你认为下面的代码是继承，那就错了，那叫做“扩展”。</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
</pre></td>
  <td class="code"><pre><span class="comment">// Returns true if the last character is c</span>
String.prototype.<span class="function">endsWith</span> = <span class="keyword">function</span>(c) {
    <span class="keyword">return</span> (c == <span class="local-variable">this</span>.charAt(<span class="local-variable">this</span>.length - <span class="integer">1</span>))
}
</pre></td>
</tr></table>
</div>

<p>看过上段代码的同学，相信在代码附近也看到了warning：<strong>反对使用自己的方法来扩展内建类型</strong>。</p>

<p>在《Javascript权威指南》第五版一书中，列出了一个继承需要的步骤，或许读起来不是特别理解。那就从源头开始，看看为什么
继承一个父类需要什么步骤。我这里说的源头是”constructor”。</p>

<p>看看下段话，摘自《JavaScript权威指南》:</p>

<blockquote>
  <p>new操作符和构造函数，用来创建了一个新的对象，然后把构造函数作为这个对象的一个方法来调用。
除此之外，在创建这个空对象以后，new设置这个对象的原型。这个对象的原型就是构造函数的prototype
属性的值，并且这个prototype的初始化值是一个对象，只带有一个属性constructor，其值就是构造函数。</p>
</blockquote>

<p>根据上面一段话，就可以将</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
</pre></td>
  <td class="code"><pre><span class="keyword">var</span> a = <span class="keyword">new</span> A();
</pre></td>
</tr></table>
</div>

<p>翻译成</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
</pre></td>
  <td class="code"><pre><span class="keyword">var</span> a = {}; A.call(a);
<span class="comment">/* If A inherit from object, A.prototype = new Object(); A.prototype.consturctor = A; */</span>
a.prototype = A.prototype;
</pre></td>
</tr></table>
</div>

<p>那如果想写一个子类B继承父类A，需要的步骤跟上面很类似:</p>

<div><table class="CodeRay"><tr>
  <td class="line-numbers"><pre><a href="#n1" name="n1">1</a>
<a href="#n2" name="n2">2</a>
<a href="#n3" name="n3">3</a>
<a href="#n4" name="n4">4</a>
<a href="#n5" name="n5">5</a>
<a href="#n6" name="n6">6</a>
<a href="#n7" name="n7">7</a>
<a href="#n8" name="n8">8</a>
<a href="#n9" name="n9">9</a>
<strong><a href="#n10" name="n10">10</a></strong>
</pre></td>
  <td class="code"><pre><span class="keyword">function</span> <span class="function">B</span>() {
    A.call(<span class="local-variable">this</span>);
    <span class="comment">/* other initialize code */</span>
}

B.prototype = <span class="keyword">new</span> A();
B.prototype.constructor = B;

<span class="comment">/* If need, delete some attribute you don't want to inherit */</span>
<span class="keyword">delete</span> B.prototype.xx;
</pre></td>
</tr></table>
</div>

<p>References &amp; Resources:</p>

<ul>
  <li>JavaScript权威指南</li>
</ul>

]]></content>
  </entry>
  
</feed>
